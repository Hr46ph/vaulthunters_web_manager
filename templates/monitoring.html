{% extends "base.html" %}

{% block title %}Monitoring - VaultHunters Web Manager{% endblock %}

{% block extra_css %}
<style>
.metric-card {
    background: var(--bs-body-bg);
    border: 1px solid var(--bs-border-color);
    border-radius: 8px;
    padding: 1rem;
    height: 100%;
}

.metric-value {
    font-size: 2rem;
    font-weight: bold;
    color: var(--bs-primary);
}

.metric-label {
    font-size: 0.875rem;
    color: var(--bs-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.chart-container {
    position: relative;
    height: 300px;
    width: 100%;
}

.status-indicator {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
}

.status-good { background-color: #198754; }
.status-warning { background-color: #ffc107; }
.status-danger { background-color: #dc3545; }
.status-unknown { background-color: #6c757d; }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <h2><i class="fas fa-chart-line"></i> Server Monitoring</h2>
        <p class="text-muted">Real-time performance monitoring and analytics</p>
    </div>
</div>

<!-- Server Health Status -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h6><i class="fas fa-heartbeat"></i> Server Health Status</h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-3">
                        <div class="d-flex align-items-center mb-2">
                            <span class="status-indicator status-unknown" id="server-status-indicator"></span>
                            <span>Server Process</span>
                            <span class="badge bg-secondary ms-auto" id="server-status-badge">Unknown</span>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="d-flex align-items-center mb-2">
                            <span class="status-indicator status-unknown" id="rcon-status-indicator"></span>
                            <span>RCON Connection</span>
                            <span class="badge bg-secondary ms-auto" id="rcon-status-badge">Unknown</span>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="d-flex align-items-center mb-2">
                            <span class="status-indicator status-unknown" id="performance-status-indicator"></span>
                            <span>Performance</span>
                            <span class="badge bg-secondary ms-auto" id="performance-status-badge">Unknown</span>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="d-flex align-items-center mb-2">
                            <span class="status-indicator status-unknown" id="disk-status-indicator"></span>
                            <span>Disk Space</span>
                            <span class="badge bg-secondary ms-auto" id="disk-status-badge">Unknown</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Configuration Panel and Recent Performance Events -->
<div class="row mb-4">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h6><i class="fas fa-cog"></i> Metrics Configuration</h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <label for="update-interval" class="form-label">Page Update Rate</label>
                        <select class="form-select form-select-sm" id="update-interval">
                            <option value="3000">3 seconds</option>
                            <option value="5000" selected>5 seconds</option>
                            <option value="10000">10 seconds</option>
                            <option value="15000">15 seconds</option>
                            <option value="30000">30 seconds</option>
                            <option value="60000">1 minute</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="chart-range" class="form-label">Chart Time Range</label>
                        <select class="form-select form-select-sm" id="chart-range">
                            <option value="0.0167">1 minute</option>
                            <option value="0.0833">5 minutes</option>
                            <option value="0.25">15 minutes</option>
                            <option value="0.5">30 minutes</option>
                            <option value="1" selected>1 hour</option>
                            <option value="3">3 hours</option>
                            <option value="6">6 hours</option>
                            <option value="12">12 hours</option>
                            <option value="24">24 hours</option>
                            <option value="72">3 days</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" id="auto-refresh" checked>
                            <label class="form-check-label" for="auto-refresh">
                                Auto Refresh
                            </label>
                        </div>
                        <small class="text-muted">
                <i class="fas fa-clock"></i> Use time range dropdown for detail
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h6><i class="fas fa-list"></i> Recent Performance Events</h6>
            </div>
            <div class="card-body">
                <div id="performance-events" style="max-height: 200px; overflow-y: auto;">
                    <div class="text-muted text-center">
                        <i class="fas fa-spinner fa-spin"></i> Loading events...
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Performance Overview Cards -->
<div class="row mb-4">
    <div class="col-md-2">
        <div class="metric-card text-center">
            <div class="metric-label">Server TPS</div>
            <div class="metric-value" id="current-tps">--</div>
            <small class="text-muted">Target: 20.0</small>
        </div>
    </div>
    <div class="col-md-2">
        <div class="metric-card text-center">
            <div class="metric-label">Lag Spikes (5min)</div>
            <div class="metric-value" id="lag-spikes-5min">--</div>
            <small class="text-muted">Last 5 minutes</small>
        </div>
    </div>
    <div class="col-md-2">
        <div class="metric-card text-center">
            <div class="metric-label">System Memory</div>
            <div class="metric-value" id="memory-usage">--</div>
            <small class="text-muted">used / total</small>
        </div>
    </div>
    <div class="col-md-2">
        <div class="metric-card text-center">
            <div class="metric-label">Average System Load</div>
            <div class="metric-value" id="system-load">--</div>
            <small class="text-muted">1-minute average</small>
        </div>
    </div>
    <div class="col-md-2">
        <div class="metric-card text-center">
            <div class="metric-label">Java Process CPU</div>
            <div class="metric-value" id="minecraft-cpu">--</div>
            <small class="text-muted">minecraft server</small>
        </div>
    </div>
    <div class="col-md-2">
        <div class="metric-card text-center">
            <div class="metric-label">Java Process RSS</div>
            <div class="metric-value" id="minecraft-memory">--</div>
            <small class="text-muted">resident memory</small>
        </div>
    </div>
</div>

<!-- Monitoring Tabs -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <ul class="nav nav-tabs card-header-tabs" id="monitoringTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="overview-tab" data-bs-toggle="tab" data-bs-target="#overview" type="button" role="tab" aria-controls="overview" aria-selected="true">
                            <i class="fas fa-chart-area"></i> Overview
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="game-performance-tab" data-bs-toggle="tab" data-bs-target="#game-performance" type="button" role="tab" aria-controls="game-performance" aria-selected="false">
                            <i class="fas fa-gamepad"></i> Game Performance
                        </button>
                    </li>
                </ul>
            </div>
            <div class="card-body">
                <div class="tab-content" id="monitoringTabContent">
                    
                    <!-- Overview Tab -->
                    <div class="tab-pane fade show active" id="overview" role="tabpanel" aria-labelledby="overview-tab">
                        
                        <!-- Overview Row 1: CPU and Memory -->
                        <div class="row mb-4">
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-microchip"></i> CPU Usage Per Core</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="chart-container">
                                            <canvas id="cpu-chart"></canvas>
                                        </div>
                                        <div class="text-center mt-2">
                                            <small class="text-muted">System CPU: <span id="system-cpu" class="fw-bold">--</span>%</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-memory"></i> System Memory Usage</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="chart-container">
                                            <canvas id="memory-chart"></canvas>
                                        </div>
                                        <div class="text-center mt-2">
                                            <small class="text-muted me-3">Swap Used: <span id="swap-used" class="fw-bold">--</span></small>
                                            <small class="text-muted">Swap Free: <span id="swap-free" class="fw-bold">--</span></small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Overview Row 2: Overall TPS and Temperature -->
                        <div class="row mb-4">
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-tachometer-alt"></i> Overall TPS History</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="chart-container">
                                            <canvas id="tps-chart"></canvas>
                                        </div>
                                        <div class="text-center mt-2">
                                            <small class="text-muted me-3">Avg TPS: <span id="tps-ave" class="fw-bold">--</span></small>
                                            <small class="text-muted">Avg Tick Time: <span id="tick-time-ave" class="fw-bold">--</span>ms</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-thermometer-half"></i> Hardware Temperature</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="chart-container">
                                            <canvas id="temperature-chart"></canvas>
                                        </div>
                                        <div class="text-center mt-2">
                                            <small class="text-muted me-3">CPU Max: <span id="temp-cpu-max" class="fw-bold">--</span>°C</small>
                                            <small class="text-muted me-3">GPU Max: <span id="temp-gpu-max" class="fw-bold">--</span>°C</small>
                                            <small class="text-muted">NVMe Max: <span id="temp-nvme-max" class="fw-bold">--</span>°C</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                    </div>

                    <!-- Game Performance Tab -->
                    <div class="tab-pane fade" id="game-performance" role="tabpanel" aria-labelledby="game-performance-tab">
                        
                        <!-- Dimension TPS Charts Container -->
                        <div id="dimension-charts-container">
                            <!-- Dimension charts will be dynamically created here -->
                        </div>

                        <!-- Game Performance Row: Lag Spikes and Player Count -->
                        <div class="row mb-4">
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-exclamation-triangle"></i> Lag Spike History</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="chart-container">
                                            <canvas id="lag-chart"></canvas>
                                        </div>
                                        <div class="text-center mt-2">
                                            <small class="text-muted me-3">Min: <span id="lag-min" class="fw-bold">--</span>ms</small>
                                            <small class="text-muted me-3">Max: <span id="lag-max" class="fw-bold">--</span>ms</small>
                                            <small class="text-muted">Ave: <span id="lag-ave" class="fw-bold">--</span>ms</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-users"></i> Player Count History</h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="chart-container">
                                            <canvas id="player-chart"></canvas>
                                        </div>
                                        <div class="text-center mt-2">
                                            <small class="text-muted">Current: <span id="player-current" class="fw-bold">--</span> / Max: <span id="player-max" class="fw-bold">--</span></small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
<script>
// Monitoring page specific JavaScript
let tpsChart, memoryChart, lagChart, cpuChart, playerChart, temperatureChart;
let dimensionCharts = {}; // Container for dimension-specific TPS charts
let availableDimensions = []; // Will be populated from API data
let dimensionChartsInitialized = false; // Track if dimension charts have been created
let monitoringData = {
    tps: [],
    memory: [],
    lagSpikes: [],
    events: [],
    cpuCores: [],
    // Historical memory breakdown
    memoryUsed: [],
    memoryBuffers: [],
    memoryCache: []
};

// Configuration state
let currentConfig = {
    update_interval: 5000, // Page refresh rate in milliseconds
    chart_range: 1,
    auto_refresh: true
};

let historicalMode = false;
let wasHistoricalMode = false; // Track previous mode
let updateInterval = null; // Store the setInterval ID for dynamic updates

// System configuration
let systemMemoryMaxGB = 64;  // Default, will be updated dynamically

// Calculate system memory max rounded to nearest power of 2
function calculateMemoryMax(totalMemoryMB) {
    const totalGB = totalMemoryMB / 1024;
    // Find next power of 2 (e.g., 30.5GB -> 32GB, 62.4GB -> 64GB)
    const powerOf2 = Math.pow(2, Math.ceil(Math.log2(totalGB)));
    return powerOf2;
}

// Local storage functions for auto-save
function saveSettingsToLocalStorage() {
    const settings = {
        update_interval: parseInt(document.getElementById('update-interval').value),
        chart_range: parseFloat(document.getElementById('chart-range').value),
        auto_refresh: document.getElementById('auto-refresh').checked
    };
    localStorage.setItem('monitoring_settings', JSON.stringify(settings));
}

function loadSettingsFromLocalStorage() {
    const savedSettings = localStorage.getItem('monitoring_settings');
    if (savedSettings) {
        try {
            const settings = JSON.parse(savedSettings);
            
            // Apply settings to UI elements
            if (settings.update_interval) {
                document.getElementById('update-interval').value = settings.update_interval;
                currentConfig.update_interval = settings.update_interval;
            }
            if (settings.chart_range) {
                document.getElementById('chart-range').value = settings.chart_range;
                currentConfig.chart_range = settings.chart_range;
            }
            if (settings.auto_refresh !== undefined) {
                document.getElementById('auto-refresh').checked = settings.auto_refresh;
                currentConfig.auto_refresh = settings.auto_refresh;
            }
            
            return settings;
        } catch (e) {
            console.error('Failed to parse saved settings:', e);
        }
    }
    return null;
}

// Initialize charts
function initializeCharts() {
    // TPS Chart - Dual Y-axis for TPS and Tick Time
    const tpsCtx = document.getElementById('tps-chart').getContext('2d');
    tpsChart = new Chart(tpsCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'TPS',
                    data: [],
                    borderColor: '#198754',
                    backgroundColor: 'rgba(25, 135, 84, 0.1)',
                    tension: 0.4,
                    fill: false,
                    yAxisID: 'y-tps',
                    pointRadius: 2,
                    pointHoverRadius: 4
                },
                {
                    label: 'Tick Time (ms)',
                    data: [],
                    borderColor: '#fd7e14',
                    backgroundColor: 'rgba(253, 126, 20, 0.1)',
                    tension: 0.4,
                    fill: false,
                    yAxisID: 'y-ticktime',
                    pointRadius: 2,
                    pointHoverRadius: 4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                'y-tps': {
                    type: 'linear',
                    position: 'left',
                    beginAtZero: true,
                    max: 20,
                    grid: {
                        color: 'rgba(25, 135, 84, 0.2)'
                    },
                    ticks: {
                        color: '#198754'
                    },
                    title: {
                        display: true,
                        text: 'TPS',
                        color: '#198754'
                    }
                },
                'y-ticktime': {
                    type: 'linear',
                    position: 'right',
                    beginAtZero: true,
                    grid: {
                        display: false // Don't display grid for secondary axis
                    },
                    ticks: {
                        color: '#fd7e14'
                    },
                    title: {
                        display: true,
                        text: 'Tick Time (ms)',
                        color: '#fd7e14'
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        },
                        unit: 'minute'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'circle',
                        padding: 15,
                        font: {
                            size: 11
                        },
                        boxWidth: 8,
                        boxHeight: 8
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.datasetIndex === 0) {
                                return 'TPS: ' + context.parsed.y.toFixed(1);
                            } else {
                                return 'Tick Time: ' + context.parsed.y.toFixed(2) + 'ms';
                            }
                        }
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });

    // Memory Chart - Stacked Area Chart
    const memoryCtx = document.getElementById('memory-chart').getContext('2d');
    memoryChart = new Chart(memoryCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Used Memory',
                    data: [],
                    borderColor: '#dc3545',
                    backgroundColor: 'rgba(220, 53, 69, 0.7)',
                    tension: 0.1,
                    fill: true
                },
                {
                    label: 'Buffers/Cache',
                    data: [],
                    borderColor: '#198754',
                    backgroundColor: 'rgba(25, 135, 84, 0.7)',
                    tension: 0.1,
                    fill: true
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: systemMemoryMaxGB * 1024, // Will be updated dynamically
                    stacked: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        callback: function(value) {
                            return (value / 1024).toFixed(1) + 'GB';
                        }
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        }
                    },
                    stacked: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'rect',
                        padding: 15,
                        font: {
                            size: 11
                        },
                        boxWidth: 12,
                        boxHeight: 8
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + (context.parsed.y / 1024).toFixed(2) + 'GB';
                        }
                    }
                },
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });

    // Lag Spikes Chart
    const lagCtx = document.getElementById('lag-chart').getContext('2d');
    lagChart = new Chart(lagCtx, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [{
                label: 'Lag Duration (ms)',
                data: [],
                backgroundColor: function(context) {
                    if (!context.parsed || context.parsed.y === undefined) {
                        return 'rgba(108, 117, 125, 0.8)'; // Default gray
                    }
                    const value = context.parsed.y;
                    if (value < 1000) return 'rgba(255, 193, 7, 0.8)';
                    if (value < 3000) return 'rgba(255, 108, 47, 0.8)';
                    return 'rgba(220, 53, 69, 0.8)';
                },
                borderColor: function(context) {
                    if (!context.parsed || context.parsed.y === undefined) {
                        return '#6c757d'; // Default gray
                    }
                    const value = context.parsed.y;
                    if (value < 1000) return '#ffc107';
                    if (value < 3000) return '#ff6c2f';
                    return '#dc3545';
                },
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        },
                        unit: 'minute'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
            }
        }
    });

    // CPU Per-Core Chart
    const cpuCtx = document.getElementById('cpu-chart').getContext('2d');
    cpuChart = new Chart(cpuCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [] // Will be populated dynamically based on CPU core count
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        },
                        unit: 'minute'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'circle',
                        padding: 15,
                        font: {
                            size: 11
                        },
                        boxWidth: 8,
                        boxHeight: 8
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '%';
                        }
                    }
                },
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });

    // Player Count Chart
    const playerCtx = document.getElementById('player-chart').getContext('2d');
    playerChart = new Chart(playerCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'Players',
                data: [],
                borderColor: '#6f42c1',
                backgroundColor: 'rgba(111, 66, 193, 0.1)',
                tension: 0.4,
                fill: true,
                pointRadius: 3,
                pointHoverRadius: 5
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        stepSize: 1,
                        callback: function(value) {
                            return Math.floor(value);
                        }
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        },
                        unit: 'minute'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
            }
        }
    });

    // Temperature Chart
    const temperatureCtx = document.getElementById('temperature-chart').getContext('2d');
    temperatureChart = new Chart(temperatureCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'CPU',
                    data: [],
                    borderColor: '#dc3545',
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    tension: 0.4,
                    fill: false,
                    pointRadius: 2,
                    pointHoverRadius: 4
                },
                {
                    label: 'GPU',
                    data: [],
                    borderColor: '#198754',
                    backgroundColor: 'rgba(25, 135, 84, 0.1)',
                    tension: 0.4,
                    fill: false,
                    pointRadius: 2,
                    pointHoverRadius: 4
                },
                {
                    label: 'NVMe',
                    data: [],
                    borderColor: '#fd7e14',
                    backgroundColor: 'rgba(253, 126, 20, 0.1)',
                    tension: 0.4,
                    fill: false,
                    pointRadius: 2,
                    pointHoverRadius: 4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: false,
                    grace: '10%', // Add 10% padding above and below data range
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        callback: function(value) {
                            return value + '°C';
                        }
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        },
                        unit: 'minute'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'circle',
                        padding: 15,
                        font: {
                            size: 11
                        },
                        boxWidth: 8,
                        boxHeight: 8
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + '°C';
                        }
                    }
                },
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

// Dimension Chart Management
function createDimensionChart(dimensionName, displayName) {
    const chartId = `dimension-chart-${dimensionName}`;
    const canvasId = `${chartId}-canvas`;
    
    // Create chart HTML
    const chartHtml = `
        <div class="col-md-6 mb-4">
            <div class="card">
                <div class="card-header">
                    <h6><i class="fas fa-globe"></i> ${displayName} TPS</h6>
                </div>
                <div class="card-body">
                    <div class="chart-container">
                        <canvas id="${canvasId}"></canvas>
                    </div>
                    <div class="text-center mt-2">
                        <small class="text-muted me-3">Avg TPS: <span id="${chartId}-tps-ave" class="fw-bold">--</span></small>
                        <small class="text-muted">Avg Tick Time: <span id="${chartId}-tick-time-ave" class="fw-bold">--</span>ms</small>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    return { chartHtml, canvasId, chartId };
}

function initializeDimensionChart(dimensionName, canvasId) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    
    // Dimension-specific colors
    const colors = {
        'overworld': { main: '#4CAF50', tick: '#8BC34A' },
        'the_nether': { main: '#F44336', tick: '#E57373' },
        'the_end': { main: '#9C27B0', tick: '#BA68C8' },
        'vault': { main: '#2196F3', tick: '#64B5F6' },
        'arena': { main: '#FF9800', tick: '#FFB74D' },
        'spatial_storage': { main: '#607D8B', tick: '#90A4AE' },
        'the_other_side': { main: '#795548', tick: '#A1887F' }
    };
    
    const colorScheme = colors[dimensionName] || { main: '#198754', tick: '#fd7e14' };
    
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'TPS',
                    data: [],
                    borderColor: colorScheme.main,
                    backgroundColor: colorScheme.main.replace(')', ', 0.1)').replace('rgb', 'rgba'),
                    tension: 0.4,
                    fill: false,
                    yAxisID: 'y-tps',
                    pointRadius: 1,
                    pointHoverRadius: 3
                },
                {
                    label: 'Tick Time (ms)',
                    data: [],
                    borderColor: colorScheme.tick,
                    backgroundColor: colorScheme.tick.replace(')', ', 0.1)').replace('rgb', 'rgba'),
                    tension: 0.4,
                    fill: false,
                    yAxisID: 'y-ticktime',
                    pointRadius: 1,
                    pointHoverRadius: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                'y-tps': {
                    type: 'linear',
                    position: 'left',
                    beginAtZero: true,
                    max: 20,
                    grid: {
                        color: colorScheme.main.replace(')', ', 0.2)').replace('rgb', 'rgba')
                    },
                    ticks: {
                        color: colorScheme.main,
                        font: { size: 10 }
                    },
                    title: {
                        display: true,
                        text: 'TPS',
                        color: colorScheme.main,
                        font: { size: 10 }
                    }
                },
                'y-ticktime': {
                    type: 'linear',
                    position: 'right',
                    beginAtZero: true,
                    grid: {
                        display: false
                    },
                    ticks: {
                        color: colorScheme.tick,
                        font: { size: 10 }
                    },
                    title: {
                        display: true,
                        text: 'Tick Time (ms)',
                        color: colorScheme.tick,
                        font: { size: 10 }
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        },
                        unit: 'minute'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        font: { size: 9 }
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'circle',
                        padding: 10,
                        font: { size: 9 },
                        boxWidth: 6,
                        boxHeight: 6
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.datasetIndex === 0) {
                                return 'TPS: ' + context.parsed.y.toFixed(1);
                            } else {
                                return 'Tick Time: ' + context.parsed.y.toFixed(2) + 'ms';
                            }
                        }
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function createDimensionCharts(dimensions) {
    const container = document.getElementById('dimension-charts-container');
    if (!container) return;
    
    // Clear existing charts
    container.innerHTML = '';
    dimensionCharts = {};
    
    if (!dimensions || dimensions.length === 0) {
        container.innerHTML = '<div class="text-center text-muted p-4"><i class="fas fa-info-circle"></i> No dimension data available</div>';
        return;
    }
    
    // Dimension display names
    const dimensionNames = {
        'overworld': 'Overworld',
        'the_nether': 'The Nether', 
        'the_end': 'The End',
        'vault': 'Vault',
        'arena': 'Arena',
        'spatial_storage': 'AE2 Spatial Storage',
        'the_other_side': 'The Other Side'
    };
    
    let chartsHtml = '<div class="row">';
    const chartConfigs = [];
    
    dimensions.forEach(dimension => {
        const displayName = dimensionNames[dimension] || dimension.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const config = createDimensionChart(dimension, displayName);
        chartConfigs.push({ dimension, ...config });
        chartsHtml += config.chartHtml;
    });
    
    chartsHtml += '</div>';
    container.innerHTML = chartsHtml;
    
    // Initialize charts after DOM is updated
    setTimeout(() => {
        chartConfigs.forEach(config => {
            try {
                dimensionCharts[config.dimension] = initializeDimensionChart(config.dimension, config.canvasId);
            } catch (error) {
                console.error(`Failed to initialize chart for ${config.dimension}:`, error);
            }
        });
    }, 100);
}

function initializeDimensionChartsFromData(metrics) {
    
    // Extract available dimensions from current metrics API response
    const detectedDimensions = [];
    
    // Check for dimension-specific TPS properties in the API response
    Object.keys(metrics).forEach(key => {
        if (key.startsWith('current_tps_')) {
            const dimension = key.replace('current_tps_', '');
            if (!detectedDimensions.includes(dimension)) {
                detectedDimensions.push(dimension);
            }
        }
    });
    
    
    // If no dimensions detected from API, fetch from database
    if (detectedDimensions.length === 0) {
        fetch('/api/monitoring/dimensions')
            .then(r => {
                return r.json();
            })
            .then(data => {
                if (data.dimensions && data.dimensions.length > 0) {
                    availableDimensions = data.dimensions;
                    createDimensionCharts(data.dimensions);
                    dimensionChartsInitialized = true;
                } else {
                }
            })
            .catch(error => {
                console.error('Failed to fetch dimensions from database:', error);
            });
        return;
    }
    
    
    availableDimensions = detectedDimensions;
    createDimensionCharts(detectedDimensions);
    dimensionChartsInitialized = true;
}

function updateDimensionCharts(metrics) {
    if (!dimensionChartsInitialized || Object.keys(dimensionCharts).length === 0) {
        return;
    }
    
    const now = new Date();
    
    // Update each dimension chart
    Object.keys(dimensionCharts).forEach(dimension => {
        const chart = dimensionCharts[dimension];
        if (!chart) return;
        
        let tpsValue = null;
        let tickTimeValue = null;
        
        // ONLY use real dimension-specific values from API - NO FALLBACKS
        if (metrics[`current_tps_${dimension}`] !== undefined) {
            tpsValue = metrics[`current_tps_${dimension}`];
        }
        if (metrics[`current_tick_time_${dimension}`] !== undefined) {
            tickTimeValue = metrics[`current_tick_time_${dimension}`];
        }
        
        // Only update chart if we have REAL data for this dimension
        if (tpsValue !== null && tickTimeValue !== null) {
            chart.data.labels.push(now);
            chart.data.datasets[0].data.push(tpsValue);
            chart.data.datasets[1].data.push(tickTimeValue);
            
            // Keep data points limited
            const maxPoints = Math.max(20, Math.ceil((currentConfig.chart_range || 1) * 72));
            if (chart.data.labels.length > maxPoints) {
                chart.data.labels.shift();
                chart.data.datasets[0].data.shift();
                chart.data.datasets[1].data.shift();
            }
            
            chart.update('none');
            updateDimensionStats(dimension, chart);
        }
        // If no real data: charts remain empty (no update) - user will see empty charts indicating missing data
    });
}

function updateDimensionStats(dimension, chart) {
    const chartId = `dimension-chart-${dimension}`;
    
    // Update TPS average
    if (chart.data.datasets[0] && chart.data.datasets[0].data.length > 0) {
        const tpsData = chart.data.datasets[0].data.filter(val => val !== null && val !== undefined);
        if (tpsData.length > 0) {
            const tpsSum = tpsData.reduce((a, b) => a + b, 0);
            const tpsAverage = tpsSum / tpsData.length;
            const tpsElement = document.getElementById(`${chartId}-tps-ave`);
            if (tpsElement) {
                tpsElement.textContent = tpsAverage.toFixed(1);
            }
        }
    }
    
    // Update tick time average
    if (chart.data.datasets[1] && chart.data.datasets[1].data.length > 0) {
        const tickTimeData = chart.data.datasets[1].data.filter(val => val !== null && val !== undefined);
        if (tickTimeData.length > 0) {
            const tickTimeSum = tickTimeData.reduce((a, b) => a + b, 0);
            const tickTimeAverage = tickTimeSum / tickTimeData.length;
            const tickTimeElement = document.getElementById(`${chartId}-tick-time-ave`);
            if (tickTimeElement) {
                tickTimeElement.textContent = tickTimeAverage.toFixed(2);
            }
        }
    }
}

// Update monitoring data
function updateMonitoringData() {
    console.log('updateMonitoringData called at', new Date().toLocaleTimeString());
    Promise.all([
        fetch('/api/monitoring/metrics').then(r => r.json()),
        fetch('/server/status').then(r => r.json())
    ])
    .then(([metrics, status]) => {
        console.log('Data received - metrics:', !!metrics, 'status:', !!status);
        
        updateMetricCards(metrics, status);
        updateCharts(metrics, status);
        
        // Update CPU chart if we have CPU data
        if (metrics.cpu_per_core && metrics.cpu_per_core.length > 0) {
            updateCpuChart(metrics);
        }
        
        // Update temperature chart and alerts
        if (metrics.temperatures) {
            updateTemperatureChart(metrics.temperatures);
            updateTemperatureAlerts(metrics.temperatures);
        }
        
        // Update Minecraft process summary
        updateMinecraftSummary(status);
        
        // Initialize dimension charts if needed (only once)
        if (!dimensionChartsInitialized) {
            initializeDimensionChartsFromData(metrics);
        }
        
        // Update dimension charts with current data
        updateDimensionCharts(metrics);
        
        updateHealthStatus(status, metrics);
        updatePerformanceEvents(metrics.events || []);
    })
    .catch(error => {
        console.error('Error updating monitoring data:', error);
        
        // Show error state in performance events
        const container = document.getElementById('performance-events');
        if (container) {
            container.innerHTML = '<div class="text-danger text-center"><i class="fas fa-exclamation-triangle"></i> Connection error</div>';
        }
    });
}

// Update metric cards
function updateMetricCards(metrics, status) {
    const tpsElement = document.getElementById('current-tps');
    if (tpsElement) {
        tpsElement.textContent = metrics.current_tps || '--';
    }
    
    const lagElement = document.getElementById('lag-spikes-5min');
    if (lagElement) {
        lagElement.textContent = metrics.lag_spikes_5min || '--';
    }
    
    const memoryElement = document.getElementById('memory-usage');
    if (memoryElement) {
        if (metrics.system_memory && metrics.system_memory.total_gb > 0) {
            // Use same rounding logic as chart: round total to nearest power of 2
            const roundedTotalGB = calculateMemoryMax(metrics.system_memory.total_mb || (metrics.system_memory.total_gb * 1024));
            memoryElement.textContent = `${metrics.system_memory.used_gb}GB / ${roundedTotalGB}GB`;
        } else {
            memoryElement.textContent = '--';
        }
    }
    
    const loadElement = document.getElementById('system-load');
    if (loadElement) {
        if (metrics.system_load !== undefined) {
            loadElement.textContent = metrics.system_load.toFixed(2);
        } else {
            loadElement.textContent = '--';
        }
    }
    
    // Update system CPU
    const systemCpuElement = document.getElementById('system-cpu');
    if (systemCpuElement) {
        if (metrics.cpu_system_avg !== undefined) {
            systemCpuElement.textContent = metrics.cpu_system_avg.toFixed(1);
        } else {
            systemCpuElement.textContent = '--';
        }
    }
    
    // Update temperature cards
    const cpuTempElement = document.getElementById('cpu-temp');
    if (cpuTempElement) {
        if (metrics.temperatures && metrics.temperatures.temperatures && metrics.temperatures.temperatures.cpu !== undefined) {
            const cpuTemp = metrics.temperatures.temperatures.cpu;
            cpuTempElement.textContent = cpuTemp.toFixed(1);
            
            // Color code based on temperature
            if (cpuTemp >= 85) {
                cpuTempElement.style.color = '#dc3545'; // Critical - red
            } else if (cpuTemp >= 75) {
                cpuTempElement.style.color = '#ffc107'; // Warning - yellow
            } else {
                cpuTempElement.style.color = 'var(--bs-primary)'; // Normal - blue
            }
        } else {
            cpuTempElement.textContent = '--';
            cpuTempElement.style.color = 'var(--bs-primary)';
        }
    }
    
    const gpuTempElement = document.getElementById('gpu-temp');
    if (gpuTempElement) {
        if (metrics.temperatures && metrics.temperatures.temperatures && metrics.temperatures.temperatures.gpu !== undefined) {
            const gpuTemp = metrics.temperatures.temperatures.gpu;
            gpuTempElement.textContent = gpuTemp.toFixed(1);
            
            // Color code based on temperature
            if (gpuTemp >= 90) {
                gpuTempElement.style.color = '#dc3545'; // Critical - red
            } else if (gpuTemp >= 80) {
                gpuTempElement.style.color = '#ffc107'; // Warning - yellow
            } else {
                gpuTempElement.style.color = 'var(--bs-primary)'; // Normal - blue
            }
        } else {
            gpuTempElement.textContent = '--';
            gpuTempElement.style.color = 'var(--bs-primary)';
        }
    }
    
    // Update server health status indicators
    updateServerHealthStatus(metrics, status);
}

// Update server health status indicators
function updateServerHealthStatus(metrics, status) {
    // Server Process Status
    const serverStatusBadge = document.getElementById('server-status-badge');
    const serverStatusIndicator = document.getElementById('server-status-indicator');
    
    if (serverStatusBadge && serverStatusIndicator) {
        if (status && status.running) {
            // Server is running
            serverStatusBadge.textContent = 'Running';
            serverStatusBadge.className = 'badge bg-success ms-auto';
            serverStatusIndicator.className = 'status-indicator status-good';
        } else if (metrics.java_memory_mb > 0) {
            // Java process exists but server might be starting
            serverStatusBadge.textContent = 'Starting';
            serverStatusBadge.className = 'badge bg-warning ms-auto';
            serverStatusIndicator.className = 'status-indicator status-warning';
        } else {
            // Server is stopped
            serverStatusBadge.textContent = 'Stopped';
            serverStatusBadge.className = 'badge bg-danger ms-auto';
            serverStatusIndicator.className = 'status-indicator status-danger';
        }
    }
    
    // RCON Connection Status
    const rconStatusBadge = document.getElementById('rcon-status-badge');
    const rconStatusIndicator = document.getElementById('rcon-status-indicator');
    
    if (rconStatusBadge && rconStatusIndicator) {
        if (metrics.rcon_status === 'connected') {
            rconStatusBadge.textContent = 'Connected';
            rconStatusBadge.className = 'badge bg-success ms-auto';
            rconStatusIndicator.className = 'status-indicator status-good';
        } else if (metrics.rcon_status === 'error') {
            rconStatusBadge.textContent = 'Error';
            rconStatusBadge.className = 'badge bg-danger ms-auto';
            rconStatusIndicator.className = 'status-indicator status-danger';
        } else {
            rconStatusBadge.textContent = 'Disconnected';
            rconStatusBadge.className = 'badge bg-warning ms-auto';
            rconStatusIndicator.className = 'status-indicator status-warning';
        }
    }
    
    // Performance Status (based on TPS and tick time)
    const performanceStatusBadge = document.getElementById('performance-status-badge');
    const performanceStatusIndicator = document.getElementById('performance-status-indicator');
    
    if (performanceStatusBadge && performanceStatusIndicator) {
        const tps = metrics.current_tps || 0;
        const tickTime = metrics.current_tick_time || 0;
        
        if (tps >= 19.5 && tickTime <= 10) {
            // Excellent performance
            performanceStatusBadge.textContent = 'Excellent';
            performanceStatusBadge.className = 'badge bg-success ms-auto';
            performanceStatusIndicator.className = 'status-indicator status-good';
        } else if (tps >= 18 && tickTime <= 25) {
            // Good performance
            performanceStatusBadge.textContent = 'Good';
            performanceStatusBadge.className = 'badge bg-success ms-auto';
            performanceStatusIndicator.className = 'status-indicator status-good';
        } else if (tps >= 15 && tickTime <= 50) {
            // Fair performance
            performanceStatusBadge.textContent = 'Fair';
            performanceStatusBadge.className = 'badge bg-warning ms-auto';
            performanceStatusIndicator.className = 'status-indicator status-warning';
        } else if (tps > 0) {
            // Poor performance
            performanceStatusBadge.textContent = 'Poor';
            performanceStatusBadge.className = 'badge bg-danger ms-auto';
            performanceStatusIndicator.className = 'status-indicator status-danger';
        } else {
            // No data
            performanceStatusBadge.textContent = 'Unknown';
            performanceStatusBadge.className = 'badge bg-secondary ms-auto';
            performanceStatusIndicator.className = 'status-indicator status-unknown';
        }
    }
    
    // Disk Space Status (if available in metrics)
    const diskStatusBadge = document.getElementById('disk-status-badge');
    const diskStatusIndicator = document.getElementById('disk-status-indicator');
    
    if (diskStatusBadge && diskStatusIndicator) {
        // For now, show as good since we don't have disk metrics in the API yet
        // This can be enhanced later when disk space monitoring is added
        diskStatusBadge.textContent = 'Good';
        diskStatusBadge.className = 'badge bg-success ms-auto';
        diskStatusIndicator.className = 'status-indicator status-good';
    }
}

// Update chart axis ranges based on selected time range
function updateChartTimeRanges(timeRangeHours) {
    const now = new Date();
    const startTime = new Date(now.getTime() - (timeRangeHours * 60 * 60 * 1000));
    
    const timeRange = {
        min: startTime,
        max: now
    };
    
    // Update all chart X-axis ranges
    [tpsChart, memoryChart, lagChart, cpuChart, playerChart, temperatureChart].forEach((chart) => {
        if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
            chart.options.scales.x.min = timeRange.min;
            chart.options.scales.x.max = timeRange.max;
            chart.update('none');
        }
    });
    
    // Update dimension charts time ranges
    Object.values(dimensionCharts).forEach((chart) => {
        if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
            chart.options.scales.x.min = timeRange.min;
            chart.options.scales.x.max = timeRange.max;
            chart.update('none');
        }
    });
}

// Update chart time range for real-time mode (removes fixed bounds for scrolling)
function updateChartTimeRangeForRealTime(newTime) {
    if (historicalMode) {
        // For historical mode, update the sliding window to follow real-time data
        const timeRangeHours = currentConfig.chart_range || 1;
        const newStartTime = new Date(newTime.getTime() - (timeRangeHours * 60 * 60 * 1000));
        
        [tpsChart, memoryChart, lagChart, cpuChart, playerChart, temperatureChart].forEach((chart) => {
            if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
                chart.options.scales.x.min = newStartTime;
                chart.options.scales.x.max = newTime;
            }
        });
        
        // Update dimension charts time ranges for historical mode
        Object.values(dimensionCharts).forEach((chart) => {
            if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
                chart.options.scales.x.min = newStartTime;
                chart.options.scales.x.max = newTime;
            }
        });
        return;
    }
    
    // Remove fixed min/max to allow Chart.js to handle scrolling naturally
    [tpsChart, memoryChart, lagChart, cpuChart, playerChart, temperatureChart].forEach((chart) => {
        if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
            // Remove fixed bounds - let Chart.js scroll naturally with data limit
            delete chart.options.scales.x.min;
            delete chart.options.scales.x.max;
        }
    });
    
    // Remove fixed bounds from dimension charts for real-time mode
    Object.values(dimensionCharts).forEach((chart) => {
        if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
            delete chart.options.scales.x.min;
            delete chart.options.scales.x.max;
        }
    });
}


// Update TPS statistics display
function updateTpsStats() {
    // Update TPS average
    if (tpsChart && tpsChart.data.datasets[0] && tpsChart.data.datasets[0].data.length > 0) {
        const tpsData = tpsChart.data.datasets[0].data.filter(val => val !== null && val !== undefined);
        if (tpsData.length > 0) {
            const sum = tpsData.reduce((a, b) => a + b, 0);
            const average = sum / tpsData.length;
            document.getElementById('tps-ave').textContent = average.toFixed(1);
        } else {
            document.getElementById('tps-ave').textContent = '--';
        }
    } else {
        document.getElementById('tps-ave').textContent = '--';
    }
    
    // Update tick time average
    if (tpsChart && tpsChart.data.datasets[1] && tpsChart.data.datasets[1].data.length > 0) {
        const tickTimeData = tpsChart.data.datasets[1].data.filter(val => val !== null && val !== undefined);
        if (tickTimeData.length > 0) {
            const sum = tickTimeData.reduce((a, b) => a + b, 0);
            const average = sum / tickTimeData.length;
            document.getElementById('tick-time-ave').textContent = average.toFixed(2);
        } else {
            document.getElementById('tick-time-ave').textContent = '--';
        }
    } else {
        document.getElementById('tick-time-ave').textContent = '--';
    }
}

// Update Lag Spike statistics display
function updateLagStats() {
    if (!lagChart || !lagChart.data.datasets[0] || lagChart.data.datasets[0].data.length === 0) {
        document.getElementById('lag-min').textContent = '--';
        document.getElementById('lag-max').textContent = '--';
        document.getElementById('lag-ave').textContent = '--';
        return;
    }
    
    const lagData = lagChart.data.datasets[0].data;
    // Filter out zero values (baseline data points) for meaningful statistics
    const nonZeroLagData = lagData.filter(value => value > 0);
    
    if (nonZeroLagData.length === 0) {
        document.getElementById('lag-min').textContent = '0';
        document.getElementById('lag-max').textContent = '0';
        document.getElementById('lag-ave').textContent = '0';
        return;
    }
    
    const min = Math.min(...nonZeroLagData);
    const max = Math.max(...nonZeroLagData);
    const sum = nonZeroLagData.reduce((a, b) => a + b, 0);
    const average = sum / nonZeroLagData.length;
    
    document.getElementById('lag-min').textContent = Math.round(min);
    document.getElementById('lag-max').textContent = Math.round(max);
    document.getElementById('lag-ave').textContent = Math.round(average);
}

// Update Temperature statistics display
function updateTemperatureStats() {
    if (!temperatureChart || !temperatureChart.data.datasets || temperatureChart.data.datasets.length === 0) {
        document.getElementById('temp-cpu-max').textContent = '--';
        document.getElementById('temp-gpu-max').textContent = '--';
        document.getElementById('temp-nvme-max').textContent = '--';
        return;
    }
    
    // CPU Max
    const cpuData = temperatureChart.data.datasets[0].data.filter(val => val !== null && val !== undefined);
    if (cpuData.length > 0) {
        const cpuMax = Math.max(...cpuData);
        document.getElementById('temp-cpu-max').textContent = cpuMax.toFixed(1);
    } else {
        document.getElementById('temp-cpu-max').textContent = '--';
    }
    
    // GPU Max
    const gpuData = temperatureChart.data.datasets[1].data.filter(val => val !== null && val !== undefined);
    if (gpuData.length > 0) {
        const gpuMax = Math.max(...gpuData);
        document.getElementById('temp-gpu-max').textContent = gpuMax.toFixed(1);
    } else {
        document.getElementById('temp-gpu-max').textContent = '--';
    }
    
    // NVMe Max
    const nvmeData = temperatureChart.data.datasets[2].data.filter(val => val !== null && val !== undefined);
    if (nvmeData.length > 0) {
        const nvmeMax = Math.max(...nvmeData);
        document.getElementById('temp-nvme-max').textContent = nvmeMax.toFixed(1);
    } else {
        document.getElementById('temp-nvme-max').textContent = '--';
    }
}

// Update Player Count statistics display
function updatePlayerStats() {
    if (!playerChart || !playerChart.data.datasets[0] || playerChart.data.datasets[0].data.length === 0) {
        document.getElementById('player-current').textContent = '--';
        document.getElementById('player-max').textContent = '--';
        return;
    }
    
    const playerData = playerChart.data.datasets[0].data;
    const max = Math.max(...playerData);
    const current = playerData[playerData.length - 1] || 0; // Get most recent value
    
    document.getElementById('player-current').textContent = current;
    document.getElementById('player-max').textContent = max;
}

// Update charts
function updateCharts(metrics, status = null) {
    const now = new Date();

    // Update TPS chart (both TPS and tick time)
    if (metrics.current_tps !== undefined || metrics.current_tick_time !== undefined) {
        tpsChart.data.labels.push(now);
        
        // Add TPS data
        if (metrics.current_tps !== undefined) {
            tpsChart.data.datasets[0].data.push(metrics.current_tps);
        } else {
            tpsChart.data.datasets[0].data.push(null);
        }
        
        // Add tick time data
        if (metrics.current_tick_time !== undefined) {
            tpsChart.data.datasets[1].data.push(metrics.current_tick_time);
        } else {
            tpsChart.data.datasets[1].data.push(null);
        }
        
        // Keep data points based on time range (15 min = 18 points, 30 min = 36 points, 1hr = 72 points, etc.)
        const timeRangeHours = currentConfig.chart_range || 1;
        const maxPoints = Math.max(20, Math.ceil(timeRangeHours * 72)); // 72 points per hour (5-second intervals)
        if (tpsChart.data.labels.length > maxPoints) {
            tpsChart.data.labels.shift();
            tpsChart.data.datasets[0].data.shift();
            tpsChart.data.datasets[1].data.shift();
        }
        
        // Update time range to include new data point
        updateChartTimeRangeForRealTime(now);
        
        tpsChart.update('none');
        
        // Update TPS statistics
        updateTpsStats();
    }

    // Update memory chart with stacked memory data
    if (metrics.system_memory) {
        // Update memory chart max scale if system memory info is available
        if (metrics.system_memory.total_mb && memoryChart) {
            const newMaxGB = calculateMemoryMax(metrics.system_memory.total_mb);
            if (newMaxGB !== systemMemoryMaxGB) {
                systemMemoryMaxGB = newMaxGB;
                memoryChart.options.scales.y.max = systemMemoryMaxGB * 1024;
                memoryChart.update('none');
            }
        }
        
        memoryChart.data.labels.push(now);
        
        // Check if we have detailed memory breakdown
        if (metrics.system_memory.used_mb !== undefined) {
            // Linux memory breakdown: show exactly what Linux reports
            const totalUsedMB = metrics.system_memory.used_mb || 0;
            const buffersMB = metrics.system_memory.buffers_mb || 0;
            const cacheMB = metrics.system_memory.cache_mb || 0;
            
            // Simple Linux memory breakdown: used includes buffers+cache, so subtract them for "actual used"
            const actualUsedMB = Math.max(0, totalUsedMB - buffersMB - cacheMB);
            const buffersAndCacheMB = buffersMB + cacheMB; // Combine buffers and cache like 'free' command
            
            memoryChart.data.datasets[0].data.push(actualUsedMB);      // Used memory (excluding buffers/cache)
            memoryChart.data.datasets[1].data.push(buffersAndCacheMB); // Buffers + Cache combined
        } else {
            // Fallback: use basic memory data and estimate breakdown
            const usedMB = (metrics.system_memory.used_gb || 0) * 1024;
            const buffersAndCacheMB = Math.round(usedMB * 0.3); // Estimate 30% for buffers+cache combined
            const actualUsedMB = Math.max(0, usedMB - buffersAndCacheMB);
            
            memoryChart.data.datasets[0].data.push(actualUsedMB);      // Used memory
            memoryChart.data.datasets[1].data.push(buffersAndCacheMB); // Buffers + Cache (estimated)
        }
        
        // Keep data points based on time range
        const timeRangeHours = currentConfig.chart_range || 1;
        const maxPoints = Math.max(20, Math.ceil(timeRangeHours * 72));
        if (memoryChart.data.labels.length > maxPoints) {
            memoryChart.data.labels.shift();
            memoryChart.data.datasets.forEach(dataset => {
                dataset.data.shift();
            });
        }
        memoryChart.update('none');
        
        // Update swap display
        updateSwapDisplay(metrics.system_memory);
    }

    // Update lag chart with recent spikes
    if (metrics.recent_lag_spikes && metrics.recent_lag_spikes.length > 0) {
        lagChart.data.labels = metrics.recent_lag_spikes.map(spike => 
            new Date(spike.timestamp)
        );
        lagChart.data.datasets[0].data = metrics.recent_lag_spikes.map(spike => spike.duration);
        lagChart.update('none');
        updateLagStats(); // Update lag statistics
    } else if (metrics.recent_lag_spikes !== undefined) {
        // No lag spikes - add a baseline point at 0 to show the chart is working
        const now = new Date();
        if (lagChart.data.labels.length === 0) {
            // Add baseline data points to show time range
            const timeRangeHours = currentConfig.chart_range || 1;
            const points = Math.min(5, Math.ceil(timeRangeHours * 12)); // 5 points max
            for (let i = 0; i < points; i++) {
                const time = new Date(now.getTime() - ((points - 1 - i) * (timeRangeHours * 60 * 60 * 1000) / points));
                lagChart.data.labels.push(time);
                lagChart.data.datasets[0].data.push(0);
            }
            lagChart.update('none');
            updateLagStats(); // Update lag statistics
        }
    }

    // Update player count chart (use server status, not metrics)
    let playerCount = 0;
    if (status && status.players !== undefined) {
        playerCount = status.players;
    }
    
    playerChart.data.labels.push(now);
    playerChart.data.datasets[0].data.push(playerCount);
    
    // Keep data points based on time range
    const timeRangeHours = currentConfig.chart_range || 1;
    const maxPoints = Math.max(20, Math.ceil(timeRangeHours * 72));
    if (playerChart.data.labels.length > maxPoints) {
        playerChart.data.labels.shift();
        playerChart.data.datasets[0].data.shift();
    }
    playerChart.update('none');
    
    // Update current player count immediately
    document.getElementById('player-current').textContent = playerCount;
    
    // Update player statistics
    updatePlayerStats();
}

// Update CPU chart
function updateCpuChart(metrics) {
    if (!metrics.cpu_per_core || metrics.cpu_per_core.length === 0) {
        return;
    }

    const now = new Date();

    // Initialize datasets if not already done
    if (cpuChart.data.datasets.length === 0) {
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', 
            '#FF9F40', '#C9CBCF', '#4BC0C0', '#FF6384', '#36A2EB',
            '#FFCE56', '#9966FF', '#FF9F40', '#C9CBCF', '#FF6384', '#36A2EB'
        ];

        for (let i = 0; i < metrics.cpu_per_core.length; i++) {
            cpuChart.data.datasets.push({
                label: `Core ${i + 1}`,
                data: [],
                borderColor: colors[i % colors.length],
                backgroundColor: colors[i % colors.length] + '20',
                tension: 0.4,
                fill: false,
                pointRadius: 2,
                pointHoverRadius: 4
            });
        }
    }

    // Add new time label
    cpuChart.data.labels.push(now);

    // Add new CPU data for each core
    metrics.cpu_per_core.forEach((coreUsage, index) => {
        if (cpuChart.data.datasets[index]) {
            cpuChart.data.datasets[index].data.push(coreUsage);
        }
    });

    // Keep data points based on time range
    const timeRangeHours = currentConfig.chart_range || 1;
    const maxPoints = Math.max(20, Math.ceil(timeRangeHours * 72));
    if (cpuChart.data.labels.length > maxPoints) {
        cpuChart.data.labels.shift();
        cpuChart.data.datasets.forEach(dataset => {
            dataset.data.shift();
        });
    }

    cpuChart.update('none');
}

// Update temperature chart
function updateTemperatureChart(temperatureData) {
    if (!temperatureData || (!temperatureData.temperatures && !temperatureData.cpu)) {
        return;
    }

    const now = new Date();
    // Handle both old and new data structure formats
    const temps = temperatureData.temperatures || temperatureData;

    // Add new time label
    temperatureChart.data.labels.push(now);

    // Ensure all datasets have the same length before adding new data
    const maxDatasetLength = Math.max(
        temperatureChart.data.datasets[0].data.length,
        temperatureChart.data.datasets[1].data.length, 
        temperatureChart.data.datasets[2].data.length
    );
    
    // Pad shorter datasets with null values to match the longest
    temperatureChart.data.datasets.forEach((dataset, index) => {
        while (dataset.data.length < maxDatasetLength) {
            dataset.data.push(null);
        }
    });

    // Add CPU temperature
    const cpuTemp = temps.cpu !== undefined ? temps.cpu : null;
    temperatureChart.data.datasets[0].data.push(cpuTemp);

    // Add GPU temperature
    const gpuTemp = temps.gpu !== undefined ? temps.gpu : null;
    temperatureChart.data.datasets[1].data.push(gpuTemp);

    // Add NVMe temperature
    const nvmeTemp = temps.nvme !== undefined ? temps.nvme : null;
    temperatureChart.data.datasets[2].data.push(nvmeTemp);

    // Keep data points based on time range
    const timeRangeHours = currentConfig.chart_range || 1;
    const maxPoints = Math.max(20, Math.ceil(timeRangeHours * 72));
    if (temperatureChart.data.labels.length > maxPoints) {
        temperatureChart.data.labels.shift();
        temperatureChart.data.datasets.forEach(dataset => {
            dataset.data.shift();
        });
    }

    temperatureChart.update('none');
    
    // Update temperature statistics
    updateTemperatureStats();
}

// Update temperature alerts
function updateTemperatureAlerts(temperatureData) {
    const container = document.getElementById('temperature-alerts');
    if (!container) return;

    if (!temperatureData || !temperatureData.alerts || temperatureData.alerts.length === 0) {
        container.innerHTML = `
            <div class="text-muted text-center">
                <i class="fas fa-check-circle text-success"></i> All temperatures normal
            </div>
        `;
        return;
    }

    const alertsHtml = temperatureData.alerts.map(alert => {
        let badgeClass = 'bg-secondary';
        let iconClass = 'fas fa-info-circle';
        
        switch(alert.type) {
            case 'critical':
                badgeClass = 'bg-danger';
                iconClass = 'fas fa-exclamation-triangle';
                break;
            case 'warning':
                badgeClass = 'bg-warning text-dark';
                iconClass = 'fas fa-exclamation-circle';
                break;
            default:
                badgeClass = 'bg-info';
                iconClass = 'fas fa-info-circle';
        }
        
        return `
            <div class="d-flex justify-content-between align-items-center mb-2 p-2 border-bottom">
                <div>
                    <div class="d-flex align-items-center">
                        <span class="badge ${badgeClass} me-2" style="font-size: 0.7em;">
                            <i class="${iconClass}"></i> ${alert.component}
                        </span>
                    </div>
                    <small class="text-muted">${alert.message}</small>
                </div>
                <strong class="text-${alert.type === 'critical' ? 'danger' : alert.type === 'warning' ? 'warning' : 'info'}">
                    ${alert.temp.toFixed(1)}°C
                </strong>
            </div>
        `;
    }).join('');

    container.innerHTML = alertsHtml;
}

// Update Minecraft process summary
function updateMinecraftSummary(status) {
    // Minecraft Process CPU
    const cpuElement = document.getElementById('minecraft-cpu');
    if (cpuElement) {
        if (status.cpu_usage !== undefined && status.running) {
            cpuElement.textContent = `${status.cpu_usage.toFixed(1)}%`;
        } else {
            cpuElement.textContent = status.running ? '--' : 'Offline';
        }
    }

    // Minecraft Process Memory
    const memoryElement = document.getElementById('minecraft-memory');
    if (memoryElement) {
        if (status.memory_usage && status.running) {
            const memoryDisplay = status.memory_usage >= 1024 
                ? `${(status.memory_usage / 1024).toFixed(1)}GB`
                : `${status.memory_usage}MB`;
            memoryElement.textContent = memoryDisplay;
        } else {
            memoryElement.textContent = status.running ? '--' : 'Offline';
        }
    }

    // Minecraft Process PID
    const pidElement = document.getElementById('minecraft-pid');
    if (pidElement) {
        if (status.pid && status.running) {
            pidElement.textContent = status.pid;
        } else {
            pidElement.textContent = status.running ? '--' : 'N/A';
        }
    }
}

// Update health status indicators
function updateHealthStatus(status, metrics) {
    // Server status
    updateStatusIndicator('server-status', status.running ? 'good' : 'danger', 
        status.running ? 'Running' : 'Stopped');

    // RCON status
    let rconStatus = 'unknown';
    let rconText = 'Unknown';
    if (metrics.rcon_status) {
        switch(metrics.rcon_status) {
            case 'connected':
                rconStatus = 'good';
                rconText = 'Connected';
                break;
            case 'disconnected':
                rconStatus = 'warning';
                rconText = 'Disconnected';
                break;
            case 'error':
                rconStatus = 'danger';
                rconText = 'Error';
                break;
            default:
                rconStatus = 'unknown';
                rconText = 'Unknown';
        }
    }
    updateStatusIndicator('rcon-status', rconStatus, rconText);

    // Performance status based on TPS
    let perfStatus = 'unknown';
    let perfText = 'Unknown';
    if (metrics.current_tps !== undefined) {
        if (metrics.current_tps >= 19) {
            perfStatus = 'good';
            perfText = 'Excellent';
        } else if (metrics.current_tps >= 17) {
            perfStatus = 'warning';
            perfText = 'Good';
        } else {
            perfStatus = 'danger';
            perfText = 'Poor';
        }
    }
    updateStatusIndicator('performance-status', perfStatus, perfText);

    // Disk status (placeholder)
    updateStatusIndicator('disk-status', 'good', 'OK');
}

// Helper function to update status indicators
function updateStatusIndicator(prefix, status, text) {
    const indicator = document.getElementById(prefix + '-indicator');
    const badge = document.getElementById(prefix + '-badge');
    
    if (indicator) {
        indicator.className = `status-indicator status-${status}`;
    }
    
    if (badge) {
        badge.className = `badge ms-auto ${status === 'good' ? 'bg-success' : 
            status === 'warning' ? 'bg-warning' : 
            status === 'danger' ? 'bg-danger' : 'bg-secondary'}`;
        badge.textContent = text;
    }
}

// Update swap display
function updateSwapDisplay(memoryData) {
    const swapUsedElement = document.getElementById('swap-used');
    const swapFreeElement = document.getElementById('swap-free');
    
    if (swapUsedElement) {
        if (memoryData.swap_used_mb !== undefined) {
            const swapUsedGB = (memoryData.swap_used_mb / 1024).toFixed(1);
            swapUsedElement.textContent = `${swapUsedGB}GB`;
        } else {
            swapUsedElement.textContent = 'N/A';
        }
    }
    
    if (swapFreeElement) {
        if (memoryData.swap_free_mb !== undefined) {
            const swapFreeGB = (memoryData.swap_free_mb / 1024).toFixed(1);
            swapFreeElement.textContent = `${swapFreeGB}GB`;
        } else {
            swapFreeElement.textContent = 'N/A';
        }
    }
}

// Update performance events
function updatePerformanceEvents(events) {
    const container = document.getElementById('performance-events');
    
    if (events.length === 0) {
        container.innerHTML = '<div class="text-muted text-center">No recent events</div>';
        return;
    }

    const eventsHtml = events.slice(0, 10).map(event => {
        // Determine severity badge color
        let badgeClass = 'bg-secondary';
        switch(event.severity) {
            case 'success': badgeClass = 'bg-success'; break;
            case 'warning': badgeClass = 'bg-warning'; break;
            case 'error': badgeClass = 'bg-danger'; break;
            case 'info': badgeClass = 'bg-info'; break;
        }
        
        return `
            <div class="d-flex justify-content-between align-items-center mb-2 p-2 border-bottom">
                <div>
                    <div class="d-flex align-items-center">
                        <span class="badge ${badgeClass} me-2" style="font-size: 0.7em;">${event.type}</span>
                    </div>
                    <small class="text-muted">${event.message}</small>
                </div>
                <small class="text-muted">${new Date(event.timestamp).toLocaleTimeString('en-GB', { hour12: false })}</small>
            </div>
        `;
    }).join('');

    container.innerHTML = eventsHtml;
}

// Dynamic update interval management
function updateRefreshRate() {
    const newInterval = parseInt(document.getElementById('update-interval').value);
    const autoRefreshEnabled = document.getElementById('auto-refresh').checked;
    
    // Clear existing interval
    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }
    
    // Set new interval if auto-refresh is enabled
    if (autoRefreshEnabled && !historicalMode) {
        updateInterval = setInterval(function() {
            updateMonitoringData();
        }, newInterval);
    }
    
    currentConfig.update_interval = newInterval;
    currentConfig.auto_refresh = autoRefreshEnabled;
    saveSettingsToLocalStorage();
}

// Load historical data for charts based on current settings
function loadHistoricalData(hours = null) {
    const timeRange = hours || parseFloat(document.getElementById('chart-range').value);
    
    // EXPLICIT CHECK: Very short ranges (30 minutes or less) - load recent historical data then switch to real-time  
    if (timeRange <= 0.5) {
        historicalMode = false;
        currentConfig.chart_range = timeRange;
        
        // Clear current data first
        clearChartData();
        
        // Set proper time range on charts
        updateChartTimeRanges(timeRange);
        
        // Load all historical data in a single bulk request
        fetch(`/api/monitoring/history/bulk?hours=${timeRange}`)
            .then(r => r.json())
            .then(async response => {
                if (response.error) {
                    throw new Error(response.error);
                }
                
                
                // Initialize CPU chart with all available cores first
                initializeCpuChartFromBulkData(response.data);
                
                // Initialize dimension charts from bulk data
                await initializeDimensionChartsFromBulkData(response.data);
                
                // Process each metric type from the bulk response
                Object.entries(response.data).forEach(([metric_type, data]) => {
                    if (data && data.length > 0) {
                        displayHistoricalMetric(metric_type, data);
                    }
                });
            
            // Update charts from loaded data
            updateChartsFromHistoricalData();
            
            // Now switch to real-time mode (don't clear data)
            switchToRealTimeMode(false);
        })
        .catch(error => {
            console.error('Failed to load historical data:', error);
            // Fallback to empty real-time mode
            switchToRealTimeMode(false);
        });
        
        return;
    }
    
    currentConfig.chart_range = timeRange;
    
    // Track previous mode
    wasHistoricalMode = historicalMode;
    
    // Use historical mode for ranges 1 hour or more
    const newHistoricalMode = timeRange >= 1.0; // 1 hour or more = historical mode
    
    if (!newHistoricalMode) {
        if (wasHistoricalMode || historicalMode) {
            // Coming from historical mode - clear data and switch
            historicalMode = false;
            clearChartData();
            switchToRealTimeMode(false); // Don't clear again
        } else {
            // Already in real-time mode - just set the mode, don't clear data
            historicalMode = false;
        }
        return;
    }
    
    // Switching to historical mode - always clear data and load historical
    historicalMode = true;
    clearChartData();
    
    // Set proper time range on charts
    updateChartTimeRanges(timeRange);
    
    // Load all historical data in a single bulk request
    fetch(`/api/monitoring/history/bulk?hours=${timeRange}`)
        .then(r => r.json())
        .then(async response => {
            if (response.error) {
                throw new Error(response.error);
            }
            
            
            // Initialize CPU chart with all available cores first
            initializeCpuChartFromBulkData(response.data);
            
            // Initialize dimension charts from bulk data
            await initializeDimensionChartsFromBulkData(response.data);
            
            // Process each metric type from the bulk response
            Object.entries(response.data).forEach(([metric_type, data]) => {
                if (data && data.length > 0) {
                    displayHistoricalMetric(metric_type, data);
                }
            });
            
            // Update charts
            updateChartsFromHistoricalData();
        })
        .catch(error => {
            console.error('Failed to load historical data:', error);
            historicalMode = false;
        });
}

// Clear chart data
function clearChartData() {
    
    // Clear historical memory data storage
    monitoringData.memoryUsed = [];
    monitoringData.memoryBuffers = [];
    monitoringData.memoryCache = [];
    
    if (tpsChart) {
        tpsChart.data.labels = [];
        tpsChart.data.datasets[0].data = [];
        tpsChart.data.datasets[1].data = [];
        tpsChart.update('none');
        updateTpsStats(); // Update stats when data is cleared
    }
    
    if (memoryChart) {
        memoryChart.data.labels = [];
        memoryChart.data.datasets.forEach(dataset => {
            dataset.data = [];
        });
        memoryChart.update('none');
    }
    
    if (cpuChart) {
        cpuChart.data.labels = [];
        cpuChart.data.datasets.forEach(dataset => {
            dataset.data = [];
        });
        cpuChart.update('none');
    }
    
    if (playerChart) {
        playerChart.data.labels = [];
        playerChart.data.datasets[0].data = [];
        playerChart.update('none');
        updatePlayerStats(); // Update stats when data is cleared
    }
    
    if (lagChart) {
        lagChart.data.labels = [];
        lagChart.data.datasets[0].data = [];
        lagChart.update('none');
        updateLagStats(); // Update stats when data is cleared
    }
    
    if (temperatureChart) {
        temperatureChart.data.labels = [];
        temperatureChart.data.datasets.forEach(dataset => {
            dataset.data = [];
        });
        temperatureChart.update('none');
        updateTemperatureStats(); // Update stats when data is cleared
    }
    
    // Clear dimension charts
    Object.keys(dimensionCharts).forEach(dimension => {
        const chart = dimensionCharts[dimension];
        if (chart) {
            chart.data.labels = [];
            chart.data.datasets[0].data = [];
            chart.data.datasets[1].data = [];
            chart.update('none');
            updateDimensionStats(dimension, chart);
        }
    });
    
    // Reset dimension charts initialization flag so they can be re-initialized with historical data
    dimensionChartsInitialized = false;
}

// Display historical metric data
function displayHistoricalMetric(metricType, data) {
    switch(metricType) {
        case 'system_memory_used_mb':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                // Store the memory data for later processing
                monitoringData.memoryUsed.push({
                    timestamp: timestamp,
                    value: point.value
                });
            });
            break;
            
        case 'system_memory_buffers_mb':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                monitoringData.memoryBuffers.push({
                    timestamp: timestamp,
                    value: point.value
                });
            });
            break;
            
        case 'system_memory_cache_mb':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                monitoringData.memoryCache.push({
                    timestamp: timestamp,
                    value: point.value
                });
            });
            break;
            
        case 'server_tps':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                if (tpsChart.data.labels.length === 0 || 
                    tpsChart.data.labels[tpsChart.data.labels.length - 1].getTime() !== timestamp.getTime()) {
                    tpsChart.data.labels.push(timestamp);
                    // Use real TPS data for first dataset
                    tpsChart.data.datasets[0].data.push(point.value);
                    // Initialize tick time dataset with null (will be filled by server_tick_time case)
                    if (tpsChart.data.datasets[1].data.length < tpsChart.data.datasets[0].data.length) {
                        tpsChart.data.datasets[1].data.push(null);
                    }
                }
            });
            updateTpsStats(); // Update stats after loading historical TPS data
            break;
            
        case 'server_tick_time':
            data.forEach((point, index) => {
                const timestamp = new Date(point.timestamp);
                
                // Find corresponding time label index or add if needed
                let labelIndex = tpsChart.data.labels.findIndex(label => 
                    label.getTime() === timestamp.getTime()
                );
                
                if (labelIndex === -1) {
                    // Add new time label if not found
                    tpsChart.data.labels.push(timestamp);
                    labelIndex = tpsChart.data.labels.length - 1;
                    // Ensure TPS dataset has corresponding entry
                    while (tpsChart.data.datasets[0].data.length <= labelIndex) {
                        tpsChart.data.datasets[0].data.push(null);
                    }
                }
                
                // Ensure tick time dataset has enough entries
                while (tpsChart.data.datasets[1].data.length <= labelIndex) {
                    tpsChart.data.datasets[1].data.push(null);
                }
                
                // Add tick time data
                tpsChart.data.datasets[1].data[labelIndex] = point.value;
            });
            updateTpsStats(); // Update stats after loading tick time data
            break;
            
        case 'system_cpu_percent':
            // CPU data is now only used for CPU chart, not TPS estimation
            // TPS data is handled separately in the 'server_tps' case above
            break;
            
        case 'player_count':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                playerChart.data.labels.push(timestamp);
                playerChart.data.datasets[0].data.push(point.value);
            });
            updatePlayerStats(); // Update stats after loading historical player data
            break;
            
        case 'temperature_cpu_celsius':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                // Ensure temperature chart has the time label
                if (temperatureChart.data.labels.length === 0 || 
                    temperatureChart.data.labels[temperatureChart.data.labels.length - 1].getTime() !== timestamp.getTime()) {
                    temperatureChart.data.labels.push(timestamp);
                }
                
                // Find the corresponding label index
                const labelIndex = temperatureChart.data.labels.findIndex(label => label.getTime() === timestamp.getTime());
                if (labelIndex !== -1) {
                    // Ensure the datasets have enough data points
                    while (temperatureChart.data.datasets[0].data.length <= labelIndex) {
                        temperatureChart.data.datasets[0].data.push(null);
                    }
                    temperatureChart.data.datasets[0].data[labelIndex] = point.value;
                }
            });
            break;
            
        case 'temperature_gpu_celsius':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                // Ensure temperature chart has the time label
                if (temperatureChart.data.labels.length === 0 || 
                    temperatureChart.data.labels[temperatureChart.data.labels.length - 1].getTime() !== timestamp.getTime()) {
                    temperatureChart.data.labels.push(timestamp);
                }
                
                // Find the corresponding label index
                const labelIndex = temperatureChart.data.labels.findIndex(label => label.getTime() === timestamp.getTime());
                if (labelIndex !== -1) {
                    // Ensure the datasets have enough data points
                    while (temperatureChart.data.datasets[1].data.length <= labelIndex) {
                        temperatureChart.data.datasets[1].data.push(null);
                    }
                    temperatureChart.data.datasets[1].data[labelIndex] = point.value;
                }
            });
            break;
            
        case 'temperature_nvme_celsius':
            data.forEach(point => {
                const timestamp = new Date(point.timestamp);
                
                // Ensure temperature chart has the time label
                if (temperatureChart.data.labels.length === 0 || 
                    temperatureChart.data.labels[temperatureChart.data.labels.length - 1].getTime() !== timestamp.getTime()) {
                    temperatureChart.data.labels.push(timestamp);
                }
                
                // Find the corresponding label index
                const labelIndex = temperatureChart.data.labels.findIndex(label => label.getTime() === timestamp.getTime());
                if (labelIndex !== -1) {
                    // Ensure the datasets have enough data points
                    while (temperatureChart.data.datasets[2].data.length <= labelIndex) {
                        temperatureChart.data.datasets[2].data.push(null);
                    }
                    temperatureChart.data.datasets[2].data[labelIndex] = point.value;
                }
            });
            break;
        
        default:
            // Handle CPU per-core metrics
            if (metricType.startsWith('system_cpu_core_') && metricType.endsWith('_percent')) {
                const coreMatch = metricType.match(/system_cpu_core_(\d+)_percent/);
                if (coreMatch) {
                    const coreIndex = parseInt(coreMatch[1]);
                    displayCpuCoreHistoricalData(coreIndex, data);
                }
            }
            // Handle dimension-specific TPS metrics (stored as server_tps_{dimension})
            else if (metricType.startsWith('server_tps_')) {
                const dimension = metricType.replace('server_tps_', '');
                if (dimensionCharts[dimension]) {
                    data.forEach(point => {
                        const timestamp = new Date(point.timestamp);
                        
                        if (dimensionCharts[dimension].data.labels.length === 0 || 
                            dimensionCharts[dimension].data.labels[dimensionCharts[dimension].data.labels.length - 1].getTime() !== timestamp.getTime()) {
                            dimensionCharts[dimension].data.labels.push(timestamp);
                            // Use real TPS data for first dataset
                            dimensionCharts[dimension].data.datasets[0].data.push(point.value);
                            
                            // Extract tick time from metadata if available
                            let tickTimeValue = null;
                            if (point.metadata && point.metadata.mean_tick_time !== undefined) {
                                tickTimeValue = point.metadata.mean_tick_time;
                            }
                            
                            // Add tick time data to second dataset
                            dimensionCharts[dimension].data.datasets[1].data.push(tickTimeValue);
                        }
                    });
                }
            }
            break;
    }
}

// Initialize CPU chart datasets by scanning bulk historical data for all CPU cores
function initializeCpuChartFromBulkData(bulkData) {
    if (cpuChart.data.datasets.length > 0) {
        return; // Already initialized
    }
    
    // Scan bulk data to find all CPU core metrics
    const coreIndices = [];
    Object.keys(bulkData).forEach(metricType => {
        if (metricType.startsWith('system_cpu_core_') && metricType.endsWith('_percent')) {
            const coreMatch = metricType.match(/system_cpu_core_(\d+)_percent/);
            if (coreMatch) {
                coreIndices.push(parseInt(coreMatch[1]));
            }
        }
    });
    
    // If no core data found, use a safe default (shouldn't happen in normal operation)
    const maxCores = coreIndices.length > 0 ? Math.max(...coreIndices) + 1 : 12;
    
    const colors = [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', 
        '#FF9F40', '#C9CBCF', '#4BC0C0', '#FF6384', '#36A2EB',
        '#FFCE56', '#9966FF', '#FF9F40', '#C9CBCF', '#FF6384', '#36A2EB'
    ];
    
    for (let i = 0; i < maxCores; i++) {
        cpuChart.data.datasets.push({
            label: `Core ${i + 1}`,
            data: [],
            borderColor: colors[i % colors.length],
            backgroundColor: colors[i % colors.length] + '20',
            tension: 0.4,
            fill: false,
            pointRadius: 2,
            pointHoverRadius: 4
        });
    }
}

// Display CPU per-core historical data
function displayCpuCoreHistoricalData(coreIndex, data) {
    if (!data || data.length === 0) {
        return;
    }
    
    // CPU chart should already be initialized by initializeCpuChartFromBulkData
    // If not, create just this core's dataset
    while (cpuChart.data.datasets.length <= coreIndex) {
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', 
            '#FF9F40', '#C9CBCF', '#4BC0C0', '#FF6384', '#36A2EB',
            '#FFCE56', '#9966FF', '#FF9F40', '#C9CBCF', '#FF6384', '#36A2EB'
        ];
        const i = cpuChart.data.datasets.length;
        cpuChart.data.datasets.push({
            label: `Core ${i + 1}`,
            data: [],
            borderColor: colors[i % colors.length],
            backgroundColor: colors[i % colors.length] + '20',
            tension: 0.4,
            fill: false,
            pointRadius: 2,
            pointHoverRadius: 4
        });
    }
    
    // Add historical data for this specific core
    data.forEach((point, index) => {
        const timestamp = new Date(point.timestamp);
        
        // Add time label only once (from first core)
        if (coreIndex === 0 && index < cpuChart.data.labels.length) {
            cpuChart.data.labels[index] = timestamp;
        } else if (coreIndex === 0) {
            cpuChart.data.labels.push(timestamp);
        }
        
        // Add data point for this core
        if (cpuChart.data.datasets[coreIndex]) {
            if (index < cpuChart.data.datasets[coreIndex].data.length) {
                cpuChart.data.datasets[coreIndex].data[index] = point.value;
            } else {
                cpuChart.data.datasets[coreIndex].data.push(point.value);
            }
        }
    });
}

// Initialize dimension charts from bulk historical data
async function initializeDimensionChartsFromBulkData(bulkData) {
    if (dimensionChartsInitialized) {
        return; // Already initialized
    }
    
    
    // Scan bulk data to find all dimension-specific metrics
    const detectedDimensions = [];
    Object.keys(bulkData).forEach(metricType => {
        if (metricType.startsWith('server_tps_')) {
            const dimension = metricType.replace('server_tps_', '');
            if (!detectedDimensions.includes(dimension)) {
                detectedDimensions.push(dimension);
            }
        }
    });
    
    
    if (detectedDimensions.length > 0) {
        availableDimensions = detectedDimensions;
        await createDimensionChartsSync(detectedDimensions);
        dimensionChartsInitialized = true;
    } else {
        // Fallback: try to fetch dimensions from the API endpoint
        try {
            const response = await fetch('/api/monitoring/dimensions');
            const data = await response.json();
            if (data.dimensions && data.dimensions.length > 0) {
                availableDimensions = data.dimensions;
                await createDimensionChartsSync(data.dimensions);
                dimensionChartsInitialized = true;
            }
        } catch (error) {
            console.error('Failed to fetch dimensions from API:', error);
        }
    }
}

// Synchronous version of createDimensionCharts for historical data loading
function createDimensionChartsSync(dimensions) {
    const container = document.getElementById('dimension-charts-container');
    if (!container) {
        console.error('Dimension charts container not found');
        return;
    }
    
    // Clear existing charts
    container.innerHTML = '';
    dimensionCharts = {};
    
    if (!dimensions || dimensions.length === 0) {
        container.innerHTML = '<div class="text-center text-muted p-4"><i class="fas fa-info-circle"></i> No dimension data available</div>';
        return;
    }
    
    // Dimension display names
    const dimensionNames = {
        'overworld': 'Overworld',
        'the_nether': 'The Nether', 
        'the_end': 'The End',
        'vault': 'Vault',
        'arena': 'Arena',
        'spatial_storage': 'AE2 Spatial Storage',
        'the_other_side': 'The Other Side'
    };
    
    let chartsHtml = '<div class="row">';
    const chartConfigs = [];
    
    dimensions.forEach(dimension => {
        const displayName = dimensionNames[dimension] || dimension.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const config = createDimensionChart(dimension, displayName);
        chartConfigs.push({ dimension, ...config });
        chartsHtml += config.chartHtml;
    });
    
    chartsHtml += '</div>';
    container.innerHTML = chartsHtml;
    
    // Initialize charts synchronously (no setTimeout)
    chartConfigs.forEach(config => {
        try {
            dimensionCharts[config.dimension] = initializeDimensionChart(config.dimension, config.canvasId);
        } catch (error) {
            console.error(`Failed to initialize chart for ${config.dimension}:`, error);
        }
    });
    
}

// Process historical memory data with proper breakdown calculation
function processHistoricalMemoryData() {
    // Clear existing memory chart data
    memoryChart.data.labels = [];
    memoryChart.data.datasets[0].data = [];
    memoryChart.data.datasets[1].data = [];
    
    // Process each used memory entry and match with buffers/cache by index
    // Since all three metrics are collected at the same time with same data point count,
    // we can match them by index instead of exact timestamp
    monitoringData.memoryUsed.forEach((entry, index) => {
        const totalUsedMB = entry.value;
        
        // Match by index instead of timestamp for more reliable pairing
        const buffersMB = (index < monitoringData.memoryBuffers.length) ? monitoringData.memoryBuffers[index].value : 0;
        const cacheMB = (index < monitoringData.memoryCache.length) ? monitoringData.memoryCache[index].value : 0;
        
        // Calculate actual used memory (same logic as real-time)
        const actualUsedMB = Math.max(0, totalUsedMB - buffersMB - cacheMB);
        const buffersAndCacheMB = buffersMB + cacheMB; // Combine buffers and cache
        
        // Add to chart (stacked format - same as real-time)
        memoryChart.data.labels.push(entry.timestamp);
        memoryChart.data.datasets[0].data.push(actualUsedMB);      // Used memory (excluding buffers/cache) - RED
        memoryChart.data.datasets[1].data.push(buffersAndCacheMB); // Buffers + Cache combined - GREEN
    });
}

// Update charts from historical data
function updateChartsFromHistoricalData() {
    // Process memory data using proper breakdown calculation
    if (monitoringData.memoryUsed.length > 0) {
        processHistoricalMemoryData();
    }
    
    if (tpsChart) {
        tpsChart.update();
    }
    if (memoryChart) {
        memoryChart.update();
    }
    if (cpuChart) {
        cpuChart.update();
    }
    if (playerChart) {
        playerChart.update();
    }
    if (temperatureChart) {
        temperatureChart.update();
        updateTemperatureStats(); // Update temperature stats from historical data
    }
    
    // Update dimension charts from historical data
    Object.keys(dimensionCharts).forEach(dimension => {
        const chart = dimensionCharts[dimension];
        if (chart) {
            chart.update();
            updateDimensionStats(dimension, chart);
        }
    });
}

// Switch back to real-time mode
function switchToRealTimeMode(clearData = true) {
    historicalMode = false;
    if (clearData) {
        clearChartData();
    }
    resetChartZoom();
    updateRefreshRate(); // Restart auto-refresh if enabled
}

// Reset zoom on all charts
function resetChartZoom() {
    if (tpsChart && tpsChart.resetZoom) tpsChart.resetZoom();
    if (memoryChart && memoryChart.resetZoom) memoryChart.resetZoom();
    if (lagChart && lagChart.resetZoom) lagChart.resetZoom();
    if (cpuChart && cpuChart.resetZoom) cpuChart.resetZoom();
    if (playerChart && playerChart.resetZoom) playerChart.resetZoom();
    if (temperatureChart && temperatureChart.resetZoom) temperatureChart.resetZoom();
    
    // Reset zoom on dimension charts
    Object.values(dimensionCharts).forEach(chart => {
        if (chart && chart.resetZoom) {
            chart.resetZoom();
        }
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeCharts();
    
    // Load saved settings from localStorage
    loadSettingsFromLocalStorage();
    
    // Set up event listeners for new controls
    document.getElementById('update-interval').addEventListener('change', function() {
        updateRefreshRate();
    });
    
    document.getElementById('auto-refresh').addEventListener('change', function() {
        updateRefreshRate();
    });
    
    document.getElementById('chart-range').addEventListener('change', function() {
        saveSettingsToLocalStorage(); // Save UI preference immediately
        loadHistoricalData(); // Load data based on new time range
        resetChartZoom(); // Reset zoom when changing time range
    });
    
    // Initial data load based on current dropdown selection (after settings are loaded)
    setTimeout(() => {
        const currentRange = parseFloat(document.getElementById('chart-range').value);
        loadHistoricalData(currentRange);
    }, 500);
    
    // Start initial auto-refresh if enabled (after a delay to ensure settings are loaded)
    setTimeout(() => {
        updateRefreshRate();
    }, 100);
    
    // Force an immediate update to ensure data loads
    setTimeout(() => {
        console.log('Forcing initial update...');
        updateMonitoringData();
    }, 1000);
});
</script>
{% endblock %}