{% extends "base.html" %}

{% block title %}Logs - VaultHunters Web Manager{% endblock %}

{% block extra_css %}
<style>
    .log-window {
        font-family: 'Courier New', monospace;
        font-size: 12px;
        height: 350px;
        overflow-y: auto;
        padding: 10px;
        border: 1px solid var(--bs-border-color);
        border-radius: 5px;
        white-space: pre-wrap;
        word-wrap: break-word;
        background-color: var(--bs-body-bg);
        color: var(--bs-body-color);
        resize: vertical;
    }
    
    /* Dark theme specific log styling */
    [data-bs-theme="dark"] .log-window {
        background-color: #1e1e1e;
        color: #ffffff;
        border-color: #444;
    }
    
    /* Light theme specific log styling */
    [data-bs-theme="light"] .log-window {
        background-color: #f8f9fa;
        color: #212529;
        border-color: #dee2e6;
    }
    
    .log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .log-controls {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    .log-controls .btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
    }
    
    .log-title {
        font-weight: 600;
        margin: 0;
        color: var(--bs-body-color);
    }
    
    .form-check {
        margin: 0;
    }
    
    .search-highlight {
        background-color: yellow;
        color: black;
        font-weight: bold;
    }
    
    [data-bs-theme="dark"] .search-highlight {
        background-color: #ffd700;
        color: #000;
    }
    
</style>
{% endblock %}

{% block content %}
    <div class="row">
        <!-- Single Log Window with Toggle -->
        <div class="col-12 mb-4">
            <div class="card">
                <div class="card-header">
                    <div class="log-header">
                        <h6 class="log-title" id="log-title">Latest Server Log</h6>
                        <div class="log-controls">
                            <!-- Log Type Toggle -->
                            <div class="btn-group me-3" role="group">
                                <input type="radio" class="btn-check" name="log-type" id="log-type-latest" autocomplete="off" checked>
                                <label class="btn btn-outline-primary btn-sm" for="log-type-latest">Latest</label>
                                
                                <input type="radio" class="btn-check" name="log-type" id="log-type-debug" autocomplete="off">
                                <label class="btn btn-outline-primary btn-sm" for="log-type-debug">Debug</label>
                                
                                <input type="radio" class="btn-check" name="log-type" id="log-type-crash" autocomplete="off">
                                <label class="btn btn-outline-primary btn-sm" for="log-type-crash">Latest Crash</label>
                                
                                <input type="radio" class="btn-check" name="log-type" id="log-type-journal" autocomplete="off">
                                <label class="btn btn-outline-primary btn-sm" for="log-type-journal">System Journal</label>
                            </div>
                            
                            <div class="input-group input-group-sm me-2" style="width: 200px;">
                                <input type="text" class="form-control" id="search-unified" placeholder="Search logs...">
                                <button class="btn btn-outline-secondary" type="button" onclick="clearSearch('unified')">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="filter-unified" title="Show only matching lines">
                                <label class="form-check-label" for="filter-unified">Filter</label>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="follow-unified" checked>
                                <label class="form-check-label" for="follow-unified">Follow</label>
                            </div>
                            <button class="btn btn-outline-primary btn-sm" onclick="refreshCurrentLog()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div id="unified-log" class="log-window">Loading log...</div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block modals %}
{% endblock %}

{% block extra_js %}
<script>
    // Global variables for unified log system
    let sseConnection = null;
    let currentLogType = 'latest';
    let autoScrollEnabled = true;
    let originalLogContent = '';
    
    // Log type configurations
    const logTypeConfig = {
        latest: { title: 'Latest Server Log', canFollow: true, endpoint: '/logs/content/latest', streamEndpoint: '/logs/stream/latest' },
        debug: { title: 'Debug Server Log', canFollow: true, endpoint: '/logs/content/debug', streamEndpoint: '/logs/stream/debug' },
        crash: { title: 'Latest Crash Report', canFollow: false, endpoint: '/logs/crash/list', streamEndpoint: null },
        journal: { title: 'System Journal', canFollow: true, endpoint: '/logs/journal', streamEndpoint: '/logs/journal/stream' }
    };
    
    // Helper function to check if user is at bottom of log window
    function isAtBottom(element) {
        const threshold = 5; // pixels from bottom
        return (element.scrollTop + element.clientHeight >= element.scrollHeight - threshold);
    }
    
    // Helper function to scroll to bottom only if auto-scroll is enabled
    function smartScroll(element) {
        if (autoScrollEnabled) {
            element.scrollTop = element.scrollHeight;
        }
    }
    
    // Search functionality for unified log
    function searchLogs() {
        const searchInput = document.getElementById('search-unified');
        const filterCheckbox = document.getElementById('filter-unified');
        const logElement = document.getElementById('unified-log');
        
        if (!searchInput || !logElement) return;
        
        const searchTerm = searchInput.value.trim();
        const filterMode = filterCheckbox ? filterCheckbox.checked : false;
        
        if (!searchTerm) {
            // No search term, show original content
            logElement.innerHTML = escapeHtml(originalLogContent);
            smartScroll(logElement);
            return;
        }
        
        const lines = originalLogContent.split('\n');
        let processedContent = '';
        
        if (filterMode) {
            // Filter mode: show only matching lines
            const matchingLines = lines.filter(line => 
                line.toLowerCase().includes(searchTerm.toLowerCase())
            );
            processedContent = matchingLines.map(line => highlightSearchTerm(line, searchTerm)).join('\n');
        } else {
            // Highlight mode: show all lines but highlight matches
            processedContent = lines.map(line => highlightSearchTerm(line, searchTerm)).join('\n');
        }
        
        logElement.innerHTML = processedContent;
        smartScroll(logElement);
    }
    
    function highlightSearchTerm(text, searchTerm) {
        if (!searchTerm) return escapeHtml(text);
        
        const escapedText = escapeHtml(text);
        const escapedSearchTerm = escapeHtml(searchTerm);
        
        // Case insensitive highlighting
        const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
        return escapedText.replace(regex, '<span class="search-highlight">$1</span>');
    }
    
    function clearSearch() {
        const searchInput = document.getElementById('search-unified');
        const filterCheckbox = document.getElementById('filter-unified');
        
        if (searchInput) {
            searchInput.value = '';
        }
        if (filterCheckbox) {
            filterCheckbox.checked = false;
        }
        
        searchLogs();
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Update log content and store original for searching
    function updateLogContent(content) {
        originalLogContent = content;
        
        
        const logElement = document.getElementById('unified-log');
        if (logElement) {
            logElement.textContent = content;
            searchLogs(); // Apply current search
            smartScroll(logElement);
        }
    }
    
    // Append to log content and store original for searching
    function appendLogContent(newContent) {
        originalLogContent += '\n' + newContent;
        
        
        searchLogs(); // Reapply search to include new content
    }
    
    // Get CSRF token
    function getCSRFToken() {
        const tokenMeta = document.querySelector('meta[name=csrf-token]');
        if (!tokenMeta) {
            console.error('CSRF token meta tag not found');
            return '';
        }
        const token = tokenMeta.getAttribute('content');
        if (!token) {
            console.error('CSRF token content is empty');
            return '';
        }
        return token;
    }
    
    // Switch log type and update title/content
    function switchLogType(newLogType) {
        if (currentLogType === newLogType) return;
        
        // Stop current streaming
        stopFollow();
        
        // Update current log type
        currentLogType = newLogType;
        
        // Update title
        const titleElement = document.getElementById('log-title');
        if (titleElement) {
            titleElement.textContent = logTypeConfig[newLogType].title;
        }
        
        // Update follow checkbox state based on log type capability
        const followCheckbox = document.getElementById('follow-unified');
        if (followCheckbox) {
            if (logTypeConfig[newLogType].canFollow) {
                followCheckbox.disabled = false;
                followCheckbox.checked = true;
                autoScrollEnabled = true; // Ensure auto-scroll is enabled for followable logs
            } else {
                followCheckbox.disabled = true;
                followCheckbox.checked = false;
                autoScrollEnabled = false; // Disable auto-scroll for non-followable logs
            }
        }
        
        // Load new log content
        refreshCurrentLog();
    }
    
    function loadLatestCrashReport() {
        const logElement = document.getElementById('unified-log');
        
        logElement.textContent = 'Loading latest crash report...';
        
        fetch('/logs/crash/list')
            .then(response => response.json())
            .then(data => {
                if (data.success && data.crash_reports && data.crash_reports.length > 0) {
                    const latestCrash = data.crash_reports[0].filename;
                    return fetch(`/logs/crash/content/${encodeURIComponent(latestCrash)}`);
                } else {
                    throw new Error('No crash reports found');
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateLogContent(data.content);
                } else {
                    updateLogContent(`Error loading crash report: ${data.error}`);
                }
            })
            .catch(error => {
                console.error('Error loading latest crash report:', error);
                updateLogContent('No crash reports found or error loading latest crash report');
            });
    }
    
    // Refresh current log
    function refreshCurrentLog() {
        const logElement = document.getElementById('unified-log');
        
        if (!logElement) return;
        
        // Handle crash reports separately
        if (currentLogType === 'crash') {
            loadLatestCrashReport();
            return;
        }
        
        const config = logTypeConfig[currentLogType];
        if (!config) return;
        
        logElement.textContent = `Loading ${config.title.toLowerCase()}...`;
        
        fetch(config.endpoint)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    updateLogContent(`Error loading ${currentLogType} log: ${data.error}`);
                } else {
                    const content = data.content || data.logs || `No ${currentLogType} log data available`;
                    updateLogContent(content);
                    
                    // Start following if enabled and supported
                    const followCheckbox = document.getElementById('follow-unified');
                    if (followCheckbox && followCheckbox.checked && config.canFollow) {
                        startFollow();
                    }
                }
            })
            .catch(error => {
                updateLogContent(`Network error loading ${currentLogType} log: ${error.message}`);
                console.error(`${currentLogType} log fetch error:`, error);
            });
    }
    
    
    // Start following current log using SSE
    function startFollow() {
        const followCheckbox = document.getElementById('follow-unified');
        if (!followCheckbox || !followCheckbox.checked) {
            return;
        }
        
        const config = logTypeConfig[currentLogType];
        if (!config || !config.canFollow || !config.streamEndpoint) {
            return;
        }
        
        // Stop existing connection if any
        stopFollow();
        
        // Set up watchdog timer to detect hanging connections
        const watchdogTimeout = setTimeout(() => {
            console.log(`SSE watchdog timeout for ${currentLogType} - connection may be hanging`);
            const checkbox = document.getElementById('follow-unified');
            if (checkbox && checkbox.checked) {
                checkbox.checked = false;
                stopFollow();
                appendLogContent('[WATCHDOG] Connection timeout - stopped following. Try refreshing the page if server is starting up.');
            }
        }, 30000); // 30 second watchdog
        
        // Create SSE connection
        const eventSource = new EventSource(config.streamEndpoint);
        sseConnection = eventSource;
        
        const logElement = document.getElementById('unified-log');
        
        eventSource.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                
                switch(data.type) {
                    case 'initial':
                        // Load initial content
                        updateLogContent(data.content || `No ${currentLogType} log data available`);
                        // Clear watchdog timer on successful initial load
                        if (watchdogTimeout) clearTimeout(watchdogTimeout);
                        break;
                        
                    case 'connected':
                        appendLogContent('[CONNECTED] Log streaming started');
                        // Clear watchdog timer on successful connection
                        if (watchdogTimeout) clearTimeout(watchdogTimeout);
                        break;
                        
                    case 'reconnected':
                        appendLogContent('[RECONNECTED] ' + data.message);
                        break;
                        
                    case 'line':
                        // Append new line
                        if (data.line.trim()) {
                            appendLogContent(data.line);
                        }
                        break;
                        
                    case 'rotation':
                        // Log rotation detected
                        appendLogContent('[LOG ROTATED] ' + data.message);
                        break;
                        
                    case 'disabled':
                        console.log(`SSE disabled for ${currentLogType}:`, data.message);
                        appendLogContent('[STREAMING DISABLED] ' + data.message);
                        // Stop following when streaming is disabled
                        const disabledCheckbox = document.getElementById('follow-unified');
                        if (disabledCheckbox) {
                            disabledCheckbox.checked = false;
                            stopFollow();
                        }
                        // Show user-friendly message and set up retry for server logs only
                        if (data.server_status === 'starting' && (currentLogType === 'latest' || currentLogType === 'debug')) {
                            appendLogContent('[INFO] Server is starting up. Log streaming will resume automatically when server is ready.');
                            
                            // Set up automatic retry every 10 seconds to check if server is ready
                            const retryInterval = setInterval(() => {
                                fetch('/server/status')
                                    .then(response => response.json())
                                    .then(statusData => {
                                        if (statusData.status === 'running') {
                                            clearInterval(retryInterval);
                                            appendLogContent('[INFO] Server is now running. Attempting to resume log streaming...');
                                            
                                            // Re-enable following checkbox and restart streaming
                                            const checkbox = document.getElementById('follow-unified');
                                            if (checkbox) {
                                                checkbox.checked = true;
                                                setTimeout(() => startFollow(), 1000); // Small delay
                                            }
                                        }
                                    })
                                    .catch(error => {
                                        console.log('Status check failed during retry:', error);
                                    });
                            }, 10000); // Check every 10 seconds
                            
                            // Clear retry after 5 minutes to prevent infinite checking
                            setTimeout(() => {
                                clearInterval(retryInterval);
                            }, 300000);
                        }
                        break;
                        
                    case 'timeout':
                        console.log(`SSE timeout for ${currentLogType}:`, data.message);
                        appendLogContent('[TIMEOUT] ' + data.message);
                        // Stop following when timeout occurs
                        const timeoutCheckbox = document.getElementById('follow-unified');
                        if (timeoutCheckbox) {
                            timeoutCheckbox.checked = false;
                            stopFollow();
                        }
                        break;
                        
                    case 'error':
                        console.error(`SSE error for ${currentLogType}:`, data.error);
                        appendLogContent('[ERROR] ' + data.error);
                        break;
                }
            } catch (e) {
                console.error(`Error parsing SSE data for ${currentLogType}:`, e);
            }
        };
        
        eventSource.onerror = function(event) {
            console.log(`SSE error for ${currentLogType}:`, event);
            // Only handle actual connection failures, ignore normal SSE events
            if (eventSource.readyState === 2) {
                console.log(`SSE connection closed for ${currentLogType}, attempting reconnect`);
                // Use shorter reconnect delay during potential startup issues
                const reconnectDelay = 2000; // 2 seconds
                setTimeout(() => {
                    const checkbox = document.getElementById('follow-unified');
                    if (checkbox && checkbox.checked) {
                        startFollow();
                    }
                }, reconnectDelay);
            } else if (eventSource.readyState === 0) {
                // Connecting state - add a timeout to prevent indefinite connecting
                setTimeout(() => {
                    if (eventSource.readyState === 0) {
                        console.log(`Connection timeout for ${currentLogType}, stopping follow`);
                        const checkbox = document.getElementById('follow-unified');
                        if (checkbox) {
                            checkbox.checked = false;
                            stopFollow();
                        }
                    }
                }, 15000); // 15 second timeout for initial connection
            }
        };
    }
    
    // Stop following current log
    function stopFollow() {
        if (sseConnection) {
            sseConnection.close();
            sseConnection = null;
        }
    }
    
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
        // Set up log type toggle buttons
        document.querySelectorAll('input[name="log-type"]').forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    const logType = this.id.replace('log-type-', '');
                    switchLogType(logType);
                }
            });
        });
        
        // Set up follow checkbox
        const followCheckbox = document.getElementById('follow-unified');
        if (followCheckbox) {
            followCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    autoScrollEnabled = true;
                    startFollow();
                } else {
                    stopFollow();
                }
            });
        }
        
        // Set up scroll event listener to detect manual scrolling
        const logElement = document.getElementById('unified-log');
        if (logElement) {
            logElement.addEventListener('scroll', function() {
                // If user scrolls away from bottom, disable auto-scroll
                if (!isAtBottom(logElement)) {
                    autoScrollEnabled = false;
                } else {
                    // If user scrolls back to bottom, re-enable auto-scroll
                    autoScrollEnabled = true;
                }
            });
        }
        
        // Set up search functionality
        const searchInput = document.getElementById('search-unified');
        if (searchInput) {
            searchInput.addEventListener('input', function() {
                searchLogs();
            });
            
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    clearSearch();
                }
            });
        }
        
        // Set up filter checkbox
        const filterCheckbox = document.getElementById('filter-unified');
        if (filterCheckbox) {
            filterCheckbox.addEventListener('change', function() {
                searchLogs();
            });
        }
        
        // Initial load
        setTimeout(() => {
            refreshCurrentLog();
        }, 100);
    });
    
    // Cleanup SSE connection when page is unloaded
    window.addEventListener('beforeunload', function() {
        stopFollow();
    });
</script>
{% endblock %}